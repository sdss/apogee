      SUBROUTINE BSYNB(NALLIN)
*
*-----------------------------------------------------------------------
*
* BSYNB is merely a continuation of BSYN, data transfered
* via scratch-file 14
*
* B takes line-absorption coefficients generated by A and
* calculates the spectra.
*
* Export version  1988-03-24  ********* Olof Morell *** Uppsala
*
*-----------------------------------------------------------------------
*
      include 'spectrum.inc'
*
      parameter (imax=1000)
*
      real pos(imax),intens(imax),mum 
      character*50 mcode
      real prof,xc(ndp)
      real fun(nrays),dmu(nrays),der(nrays)
      doubleprecision xl1,xl2
      doubleprecision del
      common/atmos/ t(ndp),pe(ndp),pg(ndp),xi(ndp),mum(ndp),ro(ndp),
     & nnntau
*
* Special for spherical
*
      COMMON /CTRAN/X(NDP),S(NDP),BPLAN(NDP),XJ(NDP),HFLUX(NDP),XK(NDP)
     & ,FJ(NDP),SOURCE(NDP),TAUS(NDP),DTAUS(NDP),JTAU0,JTAU1,ISCAT
      COMMON /TAUC/TAU(NDP),DTAULN(NDP),NTAU   
      COMMON /ROSSC/ROSS(NDP),CDUMM(NDP) 
      COMMON /RHOC/RHO(NDP)
      COMMON /CSPHER/NCORE,DIFLOG,RADIUS,RR(NDP)
      COMMON /CSTYR/MIHAL  /CTAUM/TAUM
      COMMON /SPACE2/ SPACEDUM1(NDP*7+NDP*NRAYS*5+NRAYS),
     &                nimpac,kimpac(nrays),pimpac(nrays),
     &                MMU(NDP),SPACEDUM2(NDP*2),PFEAU(NRAYS,NDP),
     &                XMU(NRAYS,NDP)
      COMMON /TRDBUG/IDEBUG
      common /limbdk/ pos,intens,totintens,tottrans
      logical debug
      real fluxme
      dimension y1c(nrays),xmuc(nrays)
      dimension fcfc(lpoint),xlm(lpoint),jlcont(lpoint)
      real sx(5000),slambda(5000),xshifted(2*ndp)
*
      COMMON/CSURF/ HSURF,Y1(NRAYS)
CCC      COMMON/CANGLE/ NMY,XMY(6),XMY2(6),WMY(6)
      COMMON/PIECES/ XL1,XL2,DEL,EPS,NMX,NLBLDU,IINT,XMYC,IWEAK
*
* extension for large number of wavelengths and lines (monster II)
      doubleprecision xlambda
      common/large/ xlambda(lpoint),maxlam,ABSO(NDP,lpoint),
     & absos(ndp,lpoint),absocont(ndp,lpoint)
*
      character*256 filterfil
      character*80 filttitle
      logical limbdark,first,findtau1
      common/filter/limbdark,ifilt,filtlam(1000),filttrans(1000),
     &              filterfil,filttitle
      logical hydrovelo
      real velocity
      common/velo/velocity(ndp),hydrovelo,computeIplus

      real taulambda(2*ndp),Iplus(2*ndp),dtaulambda(2*ndp)
      real bigsource(2*ndp)
      logical computeIplus,optthin
*
      character*4 iblnk
      DATA IBLNK/'    '/,profold/0./,first/.true./
      data debug/.false./


      PI=3.141593
*
* Initiate mode of calculation
* IINT =1  : intensity at all mu-points / output spectrum is flux spectrum!
*             intensities at all angles are stored in a separate file !
* IINT =0  : flux
* XL1      : wavelength where synthetic spectrum starts
* XL2      : wavelength where synthetic spectrum stops
* DEL      : wavelength step
* iweak not used anymore! 
******** IWEAK =1 : weak line approximation for L/KAPPA le. EPS
* note  XL2.gt.XL1

      findtau1=.false.

      if (hydrovelo) then
        findtau1=.true.
* normalize velocity to speed of light
        do k=1,ntau
          velocity(k)=velocity(k)/2.99792458d10
        enddo
      endif
*
      if(iint.eq.0) write(7,201) xl1,xl2,del
ccc      if(iweak.gt.0) write(7,202) eps
*
* Read model atmosphere
*
      read(14,rec=1) mcode,nlcont,xlm(1),bplan,xc,s,xi
      write(7,203) mcode(1:lenstr(mcode))
*
      if (iint.gt.0) then
* header for intensity file
*
        write(66) mcode
        write(66) rr(1),radius
        write(66) maxlam
      endif
*
* Continuum calculations:
*
      do jc=1,nlcont
        read(14,rec=jc) mcode,idum,xlm(jc),bplan,xc,s,xi
        do k=1,ntau
          x(k)=xc(k)
        enddo
        if (debug) then
          print*,'bsynb: calling traneq for continuum',jc,xlm(jc)
          do k=1,ntau,5
            print*,(x(kk),s(kk),kk=k,k+4)
          enddo
        endif
        call traneq
*
* Spherical fluxes
*
C FLUX TO PRINT
        hflux1c=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1c=amax1(1e-30,hflux1c)
        hflux2c=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
*        fcfc(jc)=hflux1c/pi
        fcfc(jc)=hflux1c

C        GFLUX1C=HFLUX1/PI*XLambda(J)**2/CLIGHT
C        GFLUX2C=HFLUX2/PI*XLambda(J)**2/CLIGHT
C        FFLUX1C=-2.5*ALOG10(AMAX1(GFLUX1,1E-20))
C        FFLUX2C=-2.5*ALOG10(AMAX1(GFLUX2,1E-20))
C
C OUTPUT IN CASE OF intensity calculation : STORE LIMB FUNCTION
c We don't store continuous limb darkening. BPz 28/04-09
cc       if (iint.gt.0) then
cc         write(66) xlm(jc),mmu(1),(xmu(nlx,1),y1(nlx),nlx=1,mmu(1))
cc       endif
*
* End of continuum spherical fluxes
*
        if (debug) print*,jc,xlm(jc),fcfc(jc)
        if(iint.le.0) write(7,204) fcfc(jc),xlm(jc)
CC      if(iint.gt.0) write(7,205) y1c
      enddo
*
* Start loop over wavelengths
*
      numb=0
      do j=1,maxlam
        do k=1,ntau
* the continuum opacity is already included in abso
ccc          x(k)=xc(k)+abso(k,j)
          x(k)=abso(k,j)
          s(k)=absos(k,j)
          xlsingle=xlambda(j)
          bplan(k)=bpl(T(k),xlsingle)
        enddo
        call traneq
* save traneq's fluxes
        hflux1tr=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1tr=amax1(1e-30,hflux1tr)

        if (computeIplus) then
*
************************************************************************
* Compute Iplus, for all rays, at this wavelength. BPz 08/08-2001
* calculate taulambda along the ray
          do i=1,nimpac
            ntaui=kimpac(i)
            zold=0.0
            if (hydrovelo) then
*
* This is only experimental.
* we compute the emergent intensities with a velocity field.
* We shift only the kappas. The source function is taken as 
* that in the static case. the scattering part of the opacity 
* is not shifted, to save computing time.                 
* velocity (in cm/s) in model should be positive outwards.
* If xlb_vshifted is the wavelength in the observer's frame at which
* the line position is shifted [(lambda_0-lambda)/lambda_0=v/c],
* xlb_vshifted=xlb*lshift, with lshift(k)=1.d0-velocity/c
* (Here Velocity contains velocity/c_light, and shift=1-velocity)
*
              do k=1,ntaui
                shiftmax=(-velocity(k))*xlsingle
* avoid n=0 for small shiftmax (+2)
                n=(int(abs(shiftmax)/del)+2)
                jmin=max(j-n,1)
                jmax=min(j+n,maxlam)
                n=jmax-jmin+1
                if (n.gt.5000) then
                  print*,'velocity shift is too large!'
                  print*,'shift =',shift,' n=',n
                  print*,'increase dimension !'
                  stop 'bsynb'
                endif
                do is=1,n
* slambda is of the order of 1, to minimize computation errors due to single precision.
* but we cannot shift outside the computation interval. Therefore the spectrum will
* be wrong at the beginning and end of computed range.
                  iposition=jmin+is-1
                  slambda(is)=sngl(xlambda(iposition)-xlambda(j))
                  sx(is)=abso(k,iposition)
                enddo
                shift=shiftmax*xmu(i,k)
cc                print*,' c tint', shift,n,slambda(1),slambda(n)
                call tint(n,slambda,sx,shift,xshifted(k))
* now do the back side of the shell (mirror velocity)
                shift=-shift
                call tint(n,slambda,sx,shift,xshifted(2*ntaui-k))
              enddo
            else
              do k=1,ntaui
                xshifted(k)=x(k)
                xshifted(2*ntaui-k)=x(k)
              enddo
            endif
CCC CONTINUE FROM HERE FOR BACKSDIDE !!!!!!
** n -> gives call tint(2*n, x,y,xint,yint) !! attention a la single precision !!
** puis caluler les kappas pour chaque v/c*cos(theta), avec a chaque fois l'array
** lambda (2*n), kappa(2*n) centre sur le lambda.

            if (i.gt.ncore) then
C rays that cross the atmosphere
              optthin=.true.
            else
C rays that stop at some deepest depth (the core)
              optthin=.false.
            endif

            do k=1,ntaui
              z=sqrt(rr(k)**2-pimpac(i)**2)
              bigsource(k)=source(k)
              if (k.gt.1) then
                dz=z-zold
                dzdr=dz/(rr(k)-rr(k-1))
                dtaulambda(k)=dzdr*0.5*
     &                       (xshifted(k)+s(k)+
     &                       xshifted(k-1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                if (optthin) then
c compute optical thickness for the symmetric part of the ray on the backside
                  index=2*ntaui+1-k
                  dtaulambda(index)=dzdr*0.5*
     &                     (xshifted(index)+s(k)+
     &                     xshifted(index+1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                  bigsource(index)=source(k-1)
cc                print*,'bsynb, taul',dtaulambda(k),dtaulambda(index)
                endif
              endif
              zold=z
            enddo
            taulambda(1)=(x(1)+s(1))*tau(1)/
     &                    sqrt(1.-(pimpac(i)/rr(1))**2)
            do k=2,ntaui
              taulambda(k)=taulambda(k-1)+dtaulambda(k)
            enddo
            ntauicall=ntaui
            if (optthin) then
              do k=ntaui+1,2*ntaui-1
                taulambda(k)=taulambda(k-1)+dtaulambda(k)
              enddo
              ntauicall=2*ntaui-1
            endif
            call Iplus_calc(ntauicall,taulambda,bigsource,Iplus,optthin)
            surfIplus=Iplus(1)*exp(-taulambda(1))+
     &           bigsource(1)*(1.-exp(-taulambda(1)))**2
cc              print*,'Pfeau(1,1) ',pfeau(1,1)
************************************************************************
            if (xlsingle.gt.7800..and.xlsingle.lt.7800.3) then
              if (i.eq.1) then
                print*,'bsynb; lambda=',xlsingle,' Iplus(Source):'
              endif
              do k=ntauicall,1,-1
                print*,k,taulambda(k),bigsource(k),Iplus(k)
              enddo
              if (optthin) then
                print*,'mu ',xmu(i,1),'Y1 ',y1(i),' Isurf ',
     &              surfIplus,'Thin'
              else
                print*,'mu ',xmu(i,1),'Y1 ',y1(i),' Isurf ',
     &              surfIplus,'Thick'
              endif
            endif
************************************************************************
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
            if (xmu(i,1).eq.-1.0) surfIsave=surfIplus
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
*
* Replace Y1 by surfIplus, to prepare integration of flux
            Y1(i)=surfIplus
*
* End of the ray loop
          enddo
          if (hydrovelo) then
* we compute the emergent flux at this lambda
            NMU=MMU(1)
            PX=-XMU(NMU-2,1)/(XMU(NMU-1,1)-XMU(NMU-2,1))
            QX=1.-PX
            Y1(NMU)=EXP(ALOG(Y1(NMU-2))*QX+ALOG(Y1(NMU-1))*PX)
            DO I=1,NMU
              FUN(I)=-XMU(I,1)*Y1(I)
            ENDDO
            HSURF=0.5*TRQUA2(NMU,XMU,FUN,DMU,DER)
          endif
        endif
************************************************************************
*
* Spherical fluxes
*
C FLUX TO PRINT
C renormalize to standard radius at tauross=1
        hflux1=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1=amax1(1e-30,hflux1)
        hflux2=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
*        fluxme=hflux1/pi
        fluxme=hflux1

C OUTPUT IN CASE OF intensity calculation : STORE LIMB FUNCTION
        if (iint.gt.0) then
* fluxme is normalised at radius, whereas y1 is at RR(1).
          write(66) xlambda(j),mmu(1),fluxme,
     &                (xmu(nlx,1),y1(nlx),nlx=1,mmu(1))
        endif

* interpolate continuum flux
        do jc=2,nlcont
          if(xlm(jc)-xlsingle.gt.0.) then
            jjc=jc-1
            goto 3692
          endif
        enddo
3692    continue
        if (nlcont.gt.1) then
          jjc=min(jjc,nlcont-1)
          fc=(fcfc(jjc+1)-fcfc(jjc))/
     &       (xlm(jjc+1)-xlm(jjc))*(xlsingle-xlm(jjc)) + fcfc(jjc)
        else
          fc=fcfc(1)
        endif
        prf=fluxme/fc
        if (debug) print*,j,xlsingle,fluxme,prf
*
* End of spherical fluxes
*
        prof=1.-prf
*
* find depth where tau_lambda=1



        if (findtau1) then
          taulambda(1)=tau(1)*(x(1)+s(1))
          print*,'lambda k tau tau_lambda Temp density radius R(tau=1)'
          do k=2,ntau
            taulambda(k)=taulambda(k-1)+(tau(k)-tau(k-1))*(x(k)+s(k)+
     &                   x(k-1)+s(k-1))*0.5
            if (taulambda(k).ge.1.) then
               print333,xlambda(j),k,tau(k),taulambda(k),t(k),ro(k),
     &                  rr(k),radius
333         format('radius at tau=1',f10.3,1x,i3,1x,1pe11.4,1x,
     &                1pe11.4,1x,0pf7.1,1x,
     &                1pe11.4,2(1x,1pe12.5),0p)
               goto 1966
            endif
          enddo
1966      continue
        endif
*
cc        if (limbdark) then
cc          if (xlambda(j).ge.xl1.and.xlambda(j).le.xl2) then
cc            sdel=del
cc            call weightlimb(xlsingle,sdel)
cc          endif
cc        endif
*
* Spherical intensities are stored in unit 66 for a set of angles.
* The output file ('.lim' file ) can be read with the program readlimb.f 
*
cc        if (first.and.limbdark) then
cc            first=.false.
cc            write (46,'(a)') filttitle
cc            write (46,'(a)') filterfil(1:lenstr(filterfil))
cc            write (46,*) '''lambda min, max : ''',filtlam(1),
cc     &                   filtlam(ifilt)
cc            write (46,*) '''sampling : ''',sdel
cc            write (46,*) '''radius tauross=1, max : ''',radius,rr(1)
cc            write (46,*)     
cc          endif

* store spectrum in x,y format
* integral_inf^+inf (fluxme) = sigma Teff^4

        if (iint.eq.0) then
          if (computeIplus) then
c We should have surface flux here!
            write(46,2018) xlambda(j),prf,fluxme,hflux1tr,surfIsave
          else
            write(46,1964) xlambda(j),prf,fluxme
1964        format(f11.3,1x,f10.5,1x,1pe12.5)
          endif
        else if (iint.gt.0) then
* We store an additional column, which is the intensity at mu=0
          if (computeIplus) then
            write(46,2018) xlambda(j),prf,fluxme,hflux1tr,surfIsave
          else
            write(46,1965) xlambda(j),prf,fluxme,y1(1)
1965        format(f11.3,1x,f10.5,1x,1pe12.5,1x,e12.5)
2018        format(f11.3,1x,f10.5,1x,1pe12.5,1x,e12.5,1x,e12.5)
          endif
        endif

*
* End of wavelength loop
      enddo
*
* writes limbdark profile if wanted
*
cc      if (limbdark) then
cc* filterfile name / lambda start and end / stellar radius tau=1 and max /
cc* intens at center of disk (weighted with filter transmission) /
cc* number of profile points /
cc* profile: impact parameter, normalized to radius tau=1, 
cc* profile normalized to 1 at center.
cc
cc        write (47,'(a)') filttitle
cc        write (47,'(a)') filterfil(1:lenstr(filterfil))
cc        write (47,*) '''lambda min, max : ''',filtlam(1),filtlam(ifilt)
cc        write (47,*) '''sampling : ''',sdel
cc        write (47,*)     '''radius tauross=1, max : ''',radius,rr(1)
cc        write (47,*)     
cc     &  '''integrated I at center of disk, int. filter trans.: ''',
cc     &       totintens,tottrans
cc        write (47,*)     imax
cc        do i=1,imax
cc          write (47,*)   pos(i),rr(1)/radius*pos(i),intens(i)/totintens
cc        enddo
cc      endif

      call clock
      RETURN
*
  100 FORMAT(4X,I1,6X,I3)
  207 FORMAT(' SPECTRUM CALCULATED FOR THE FOLLOWING ',I3,' LINES'
     &      /' ELEMENT LAMBDA XI(EV) LOG(GF) LOG(ABUND) LINE NO')
  208 FORMAT('   ',A2,I2,F9.2,F5.2,1X,F6.2,3X,F7.2,4X,I5)
  200 FORMAT(' INTENSITY SPECTRUM AT MU=',F6.2,' BETWEEN',F10.3,
     &      ' AND',F10.3,' A WITH STEP',F6.3,' A')
  201 FORMAT(' FLUX SPECTRUM BETWEEN',F10.3,' A AND ',F10.3,' A WITH',
     &       ' STEP',F6.3,' A')
  202 FORMAT(' ***WEAK LINE APPROX FOR L/KAPPA L.T.',F7.4)
  203 FORMAT(' MODEL ATMOSPHERE:',A)
  204 FORMAT(' CONTINUUM FLUX=',E12.4, ' AT ',f10.2,'AA')
  205 FORMAT(' CONTINUUM INTENSITY=',E12.4)
  206 FORMAT(1X,10F8.4)
*
      END
